<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no"/>
  <meta name="theme-color" content="#00838f"/>
  <title>Josh Korn</title>
    <!-- <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/0.95.3/css/materialize.min.css"> -->
  <script src="https://code.jquery.com/jquery-2.1.3.min.js"></script>


  <script type="text/javascript" src="js/jquery.easy-pie-chart.js"></script>

  <link href="css/jquery.easy-pie-chart.css" type="text/css" rel="stylesheet" media="screen,projection"/>

  <link href="css/materialize.css" type="text/css" rel="stylesheet" media="screen,projection"/>
  <link href="css/style.css" type="text/css" rel="stylesheet" media="screen,projection"/>
  <link rel="shortcut icon" href="http://i.imgur.com/QIhSLZ3.gif">
</head>
<body background="topography.png">
  <script src="js/materialize.js"></script>
  <script>
  $(document).ready(function() {
      $(".button-collapse").sideNav();
      $('.scrollspy').scrollSpy();
      $('.parallax').parallax();
      $('.collapsible').collapsible({
      accordion : false
      });
      $('.chart').easyPieChart({
        animate: 5000,
        scaleColor: false,
        size: 160,
        lineWidth: 25,
        lineCap: 'butt',
        barColor: "#00838f"
    });
  });
  </script>
  <nav>
    <div class="nav-wrapper hide-on-small-and-down">
      <div class="navbar-fixed">
        <nav class="white">
          <div class="center row">
            <div class="col s12" style="margin-top:-12px;">
              <ul class="section table-of-contents hide-on-small-and-down">
                <li class="col m2 offset-m1"><a href="#summary">Summary</a></li>
                <li class="col m2"><a href="#background">Background</a></li>
                <li class="col m2"><a href="#proposal">Proposal</a></li>
                <li class="col m2"><a href="#checkpoint">Checkpoint</a></li>
                <li class="col m2"><a href="#final">Final</a></li>
              </ul>
            </div>
          </div>
        </nav>
      </div>
    </div>
    <div class="nav-wrapper hide-on-med-and-up">
      <a class="brand-logo hide-on-med-and-up cyan-text text-darken-3">Flows</a>
      <div class="navbar">
        <a href="#" data-activates="mobile-demo" class="button-collapse"><i class="hide-on-med-and-up mdi-navigation-menu"></i></a>
        <ul class="side-nav" id="mobile-demo">
          <li><a href="#summary" class="cyan-text text-darken-3">Summary</a></li>
          <li><a href="#background" class="cyan-text text-darken-3">Background</a></li>
          <li><a href="#proposal" class="cyan-text text-darken-3">Proposal</a></li>
          <li><a href="#checkpoint" class="cyan-text text-darken-3">Checkpoint</a></li>
          <li><a href="#final" class="cyan-text text-darken-3">Final</a></li>
        </ul>
      </div>
    </div>
  </nav>
  <div id="index-banner" class="parallax-container valign-wrapper">
    <div id="summary" class="section scrollspy container no-pad-bot">
      <div class="container"> 
          <h2 class="header center cyan-text text-darken-3">Flo: A Simple C++ Library for Parallel Max Flow Computations</h1>
          <h5 class="center header col s12 black-text">A small library for easily creating network flow graphs, and performing max-flow computations on multi-core CPUs and NVIDIA GPUs.</h5>
          <h4 class="center header col s12 black-text">by Joshua Korn</h4>
      </div>
    </div>
  </div>
  
  <div id="background" class="section scrollspy no-pad-bot">
    <h2 class="center cyan-text text-darken-3">Background</h2>
    <div class="row container">
      <p style="font-size:20px;">Network flows are everywhere, across mathematics, computer science, and operations research. From finding bipartite matchings to modeling traffic to image segmenting, a lot of unique problems can be modeled as a network flow.  Commonly, we wish to find the maximum flow through a given network. There are many different algorithms to do so, but most of them are inherently sequential.  As networks get large, as is the case in many real-life applications, these algorithms may not always have optimal performance, and as such, I wish to investigate how much speedup can be obtained with these algorithms due to parallelism.</p>
    </div>
  </div>

  <div id="proposal" class="section scrollspy no-pad-bot">
    <h2 class="center cyan-text text-darken-3">Proposal</h2>
    <div class="row container">
     <p style="font-size:20px;">Parallelizing max-flow algorithms is inherently challenging, as with other graph algorithms, there are many dependencies between nodes, and most common algorithms used for max-flow computations are sequential.  There is some, but not much research on the topic of parallelizing these algorithms. Figuring out how to partition a given graph over workers for optimal parallelization, and minimizing the need for atomicity and communication as much as possible, will be the main challenge.</p>
     <p style="font-size:20px;">The only starter code I may utilize is my parallel BFS and some of the test graphs from Assignment 3. I plan on developing on the GHC machines, which have 8 cores that support hyperthreading (16 logical cores) and a GTX 1080. The GHC machines are perfect, since they are easily accessible, and allow me to test both my parallel CPU and GPU implementations. I will be referencing algorithms that I learned in 15-451, as well as some papers on parallel flow algorithms that I will cite as they are used.</p>
      <p style="font-size:20px;">For this project, I wish to take advantage of parallelism available in modern CPUs and GPUs to obtain a significant speedup in certain max flow algorithms. In particular, I plan on implementing three max flow algorithms in three ways (sequential, parallel for CPUs, and parallel for GPUs using NVIDIA CUDA) - these three algorithms are Edmonds-Karp, Dinic's, and Push-relabel (Goldberg-Tarjan). The first of these algorithms, Edmonds-Karp, is parallelizable between iterations since it uses BFS to find shortest paths. Dinic's algorithm uses BFS as a subroutine as well, and uses the concept of a layered graph to obtain a better asymptotic runtime than Edmonds-Karp. Finally, the Push-relabel algorithm is inherently parallel over vertices, similar to bottom-up BFS, and is already considered one of the most efficient max-flow algorithms, so a large speedup is expected. After implementing all of this, I wish to benchmark the performance of these algorithms on various test graphs (looking at both how the algorithms compare against each other on the same platform, and the speedups obtained from sequential to CPU to GPU). Finally, I want to package these algorithms into a simple C++ library that allows users to easily create graphs and run these algorithms on them (with options to run on CPU or GPU).</p>
      <p style="font-size:20px;">If I have time afterwards, I would like to provide some example use cases of this library, such as finding bipartite matchings and doing image segmentation. If possible, I'd also like to have the library dynamically figure out which algorithm would be better to use based on the input graph's properties, instead of having the user choose the algorithm.</p>
      <p style="font-size:20px;">My demonstration would be showing the various speedup graphs described earlier, both on test graphs, and, time permitting, on the practical examples I will create. The goal is to obtain significant speedups, especially on larger graphs, on all of these algorithms as compared to the baseline sequential implementations.</p>

      <h3 class="center cyan-text text-darken-3">Schedule</h3>

      <table class="striped">
        <thead>
          <tr>
              <th>End Date</th>
              <th>Goals</th>
          </tr>
        </thead>

        <tbody>
          <tr>
            <td>Tue, 4/25 (Checkpoint)</td>
            <td>Determine graph representation, create testing and timing harnesses with graph generation, write sequential Edmonds-Karp and test correctness.</td>
          </tr>
          <tr>
            <td>Tue, 5/2</td>
            <td>Write sequential version of other two algorithms and test for correctness, benchmark times on same graphs.</td>
          </tr>
          <tr>
            <td>Fri, 5/5</td>
            <td>Finish all CPU parallel implementations, benchmark against sequential code.</td>
          </tr>
          <tr>
            <td>Tue, 5/9</td>
            <td>Finish all GPU implementations and benchmarking.</td>
          </tr>
          <tr>
            <td>Thu, 5/11</td>
            <td>Create all speedup plots for writeup, and create C++ library.</td>
          </tr>
          <tr>
            <td>Fri, 5/12</td>
            <td>Extras (special examples, dynamic algorithm choosing), time permitting. Final writeup.</td>
          </tr>
        </tbody>
      </table>
    </div>
  </div>

  <div id="checkpoint" class="section scrollspy no-pad-bot">
    <h2 class="center cyan-text text-darken-3">Checkpoint</h2>
    <div class="row container">
      <p style="font-size:20px;">The updated schedule is above, and includes everything I have completed for this checkpoint. In particular, I have created a basic testing framework, a system to randomly generate connected graphs to be used for testing, and have decided to go with an adjacency matrix representation for my graphs, where entry (i, j) gives the capacity of that edge. This will take up a bit more memory, but makes accesses a lot quicker and more organized than with using my original plan of an adjacency list representation. Finally, I have a sequential Edmonds-Karp implementation that I will use as a baseline correctness test for my other algorithms. I believe I am still on track to produce all of my deliverables - my goals remain the same. The extras I will have a day or two to implement if I stay on track, so I am not sure if those will happen. What I would want to show at the competition is still the same, namely the different speedup plots obtained. Because I have just set up the foundation for my project so far, I don't have any preliminary results. Currently I don't have any issues that are cause for concern.</p>
    </div>
  </div>

  <div id="final" class="section scrollspy no-pad-bot">
    <h2 class="center cyan-text text-darken-3">Final</h2>
    <div class=" row container">
      <h3 class="center cyan-text text-darken-3">Summary</h3>
      <p style="font-size:20px;">I implemented three max flow algorithms - Edmonds-Karp, Dinic's, and Push-relabel - both sequentially and in parallel using OpenMP, and analyzed speedups obtained. In particular, I focused on a lock-free Push-relabel algorithm, and was able to obtain up to 6x speedup on tested graphs. I also parallelized this algorithm on GPUs with a single CUDA thread per vertex to benchmark performance, and noticed poor performance, for reasons discussed later. Finally, I wrote a small class-based library to easily represent graphs and run max flow algorithms on them. Tests were run on GHC35, which has an 8-core hyperthreaded CPU and a GTX 1080 GPU. All tests were run using fixed, randomly generated connected graphs with max edge capacity of 50, and results were averaged over multiple trials. Code can be found on my GitHub (link in footer).</p>
      <div class="col m12">
        <p style="font-size:20px;">Example usage of the library:</p>
        <!-- HTML generated using hilite.me --><div style="background: #272822; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #f8f8f2">FlowGraph</span> <span style="color: #a6e22e">graph</span><span style="color: #f8f8f2">(</span><span style="color: #ae81ff">6</span><span style="color: #f8f8f2">);</span>
<span style="color: #f8f8f2">std</span><span style="color: #f92672">::</span><span style="color: #f8f8f2">vector</span><span style="color: #f92672">&lt;</span><span style="color: #f8f8f2">std</span><span style="color: #f92672">::</span><span style="color: #f8f8f2">tuple</span><span style="color: #f92672">&lt;</span><span style="color: #66d9ef">int</span><span style="color: #f8f8f2">,</span> <span style="color: #66d9ef">int</span><span style="color: #f8f8f2">,</span> <span style="color: #66d9ef">int</span><span style="color: #f92672">&gt;&gt;</span> <span style="color: #f8f8f2">edges;</span>
<span style="color: #f8f8f2">edges.push_back(std</span><span style="color: #f92672">::</span><span style="color: #f8f8f2">make_tuple(</span><span style="color: #ae81ff">0</span><span style="color: #f8f8f2">,</span> <span style="color: #ae81ff">1</span><span style="color: #f8f8f2">,</span> <span style="color: #ae81ff">4</span><span style="color: #f8f8f2">));</span> <span style="color: #75715e">// (from, to, capacity)</span>
<span style="color: #f8f8f2">edges.push_back(std</span><span style="color: #f92672">::</span><span style="color: #f8f8f2">make_tuple(</span><span style="color: #ae81ff">0</span><span style="color: #f8f8f2">,</span> <span style="color: #ae81ff">2</span><span style="color: #f8f8f2">,</span> <span style="color: #ae81ff">2</span><span style="color: #f8f8f2">));</span>
<span style="color: #f8f8f2">edges.push_back(std</span><span style="color: #f92672">::</span><span style="color: #f8f8f2">make_tuple(</span><span style="color: #ae81ff">1</span><span style="color: #f8f8f2">,</span> <span style="color: #ae81ff">3</span><span style="color: #f8f8f2">,</span> <span style="color: #ae81ff">3</span><span style="color: #f8f8f2">));</span>
<span style="color: #f8f8f2">edges.push_back(std</span><span style="color: #f92672">::</span><span style="color: #f8f8f2">make_tuple(</span><span style="color: #ae81ff">2</span><span style="color: #f8f8f2">,</span> <span style="color: #ae81ff">4</span><span style="color: #f8f8f2">,</span> <span style="color: #ae81ff">3</span><span style="color: #f8f8f2">));</span>
<span style="color: #f8f8f2">edges.push_back(std</span><span style="color: #f92672">::</span><span style="color: #f8f8f2">make_tuple(</span><span style="color: #ae81ff">3</span><span style="color: #f8f8f2">,</span> <span style="color: #ae81ff">5</span><span style="color: #f8f8f2">,</span> <span style="color: #ae81ff">2</span><span style="color: #f8f8f2">));</span>
<span style="color: #f8f8f2">edges.push_back(std</span><span style="color: #f92672">::</span><span style="color: #f8f8f2">make_tuple(</span><span style="color: #ae81ff">4</span><span style="color: #f8f8f2">,</span> <span style="color: #ae81ff">5</span><span style="color: #f8f8f2">,</span> <span style="color: #ae81ff">4</span><span style="color: #f8f8f2">));</span>
<span style="color: #f8f8f2">edges.push_back(std</span><span style="color: #f92672">::</span><span style="color: #f8f8f2">make_tuple(</span><span style="color: #ae81ff">3</span><span style="color: #f8f8f2">,</span> <span style="color: #ae81ff">0</span><span style="color: #f8f8f2">,</span> <span style="color: #ae81ff">5</span><span style="color: #f8f8f2">));</span>
<span style="color: #f8f8f2">graph.AddEdges(</span><span style="color: #f92672">&amp;</span><span style="color: #f8f8f2">edges);</span>
<span style="color: #f8f8f2">graph.DeleteEdge(</span><span style="color: #ae81ff">3</span><span style="color: #f8f8f2">,</span> <span style="color: #ae81ff">0</span><span style="color: #f8f8f2">);</span>
<span style="color: #66d9ef">auto</span> <span style="color: #f8f8f2">result</span> <span style="color: #f92672">=</span> <span style="color: #f8f8f2">graph.FlowEdmondsKarp();</span>
</pre></div>
      </div>
    </div>
    <div class="center row container">
      <h3 class="center cyan-text text-darken-3">Background</h3>
      <p style="font-size:20px;">See main section "Background" for motivation. All of these algorithms operate on a graph with specified edge capacities, and output the value of the max flow along with all edges that have positive flow pushed on them. The main challenge is that most flow algorithms are not inherently parallelizable. Many algorithms use the concept of a residual graph, which is essentially the state of the graph after flow is pushed during a single iteration. Therefore, synchronization is needed between iterations - flow cannot be pushed on the residual graph if the residual graph is not yet created. Algorithms that don’t use residual graphs, such as Push-relabel, instead require massive amounts of system-wide synchronization, as explained later. As well, for general graphs, there is not much data locality. This especially true for the Push-relabel algorithm, which keeps track of heights and excess flow values for each node, which needs to be constantly accessed by all neighbors. For all of these reasons, there is not much research done in parallel flows. As well, existing sequential algorithms are, in most practical uses, extremely fast.</p>

      <p style="font-size:20px;">The three algorithms I investigated were the following:</p>
      <div class="col s12 m4">
        <h4 class="center cyan-text text-darken-3">Edmonds-Karp</h4>
        𝑂(𝑛𝑚&sup2;). Uses BFS as a subroutine to pick the shortest in the residual graph at each iteration. Not parallelizable between iterations.
      </div>
      <div class="col s12 m4">
        <h4 class="center cyan-text text-darken-3">Dinic's</h4>
        𝑂(𝑛&sup2;𝑚). Uses BFS at each iteration to construct a layered graph (edges only from depth 𝑑 to 𝑑+1 from the source vertex). Then, the algorithm uses DFS to find a blocking flow, where every path in the layered graph has a saturated edge (no residual capacity). Only the layered graph construction is parallelizable.
      </div>
      <div class="col s12 m4">
        <h4 class="center cyan-text text-darken-3">Push-relabel</h4>
        𝑂(𝑛&sup2;𝑚). Uses the idea of height labels and excess flow – if a node has excess flow, try to push it to a lower height neighbor, or else try to increase your height. This algorithm is much more parallelizable (can parallelize over vertices), and as a result was the main focus of this project. Due to excess flows, this algorithm does not necessarily maintain a valid flow until the very end. An analogy to how this algorithm operates is how water flows through pipes.
      </div>
    </div>
    <div class="center row container">
      <h3 class="center cyan-text text-darken-3">Approach</h3>
      <div class="col s12">
        <p style="font-size:20px;">All code was done in C++/CUDA. CPU parallelism was done with OpenMP. For both Edmonds-Karp and Dinic's, the only really parallelizable part of the algorithm are the BFS subroutines. Therefore, I used modified versions of my OpenMP parallel top-down BFS implementation from assignment 3 in these algorithms to obtain speedups. Just as in the assignment, threads map to local frontiers that are then merged together with fetch-and-add operations. The main focus of parallelizing these two algorithms was for analysis (see the "Results" subsection), and not so much a focus on the code itself. I was originally intending on trying to parallelize these algorithms on GPUs as well, but realized that it wouldn't be effective since the only parallelizable routine is BFS, which due to access patterns in general graphs and low arithmetic intensity, would not benefit (and would most likely observe negative speedups) from GPU parallelization.</p>
      </div>
      <div class="col s12">
        <p style="font-size:20px;">My main focus was on parallelizing the Push-relabel algorithm.</p>
      </div>
    </div>
    <div class="row container">
      <h3 class="center cyan-text text-darken-3">Results</h3>
      <p class="center" style="font-size:20px;">COMING REALLY SOON</p>
    </div>
    <div class="row container">
      <h3 class="center cyan-text text-darken-3">References</h3>
      <p class="center" style="font-size:20px;">COMING REALLY SOON</p>
    </div>
    <div class="center row">
      <img src="jkorn2.jpeg" class="circle center">
    </div>
    
  </div>
  </body>

  <footer class="center page-footer cyan darken-3">
    <div class="container hide-on-small-and-down">
      <div class="valign-wrapper row">
        <div class="col s12 m3">
          <a href="tel:973-879-6362"><i class="small mdi-communication-phone white-text"></i></a>
          <a href="tel:973-879-6362"><p class="white-text">(973) 879-6362</p></a>
        </div>
        <div class="col s12 m3">
          <a href="mailto:jkorn@cmu.edu"><i class="small mdi-communication-email white-text"></i></a>
          <a href="mailto:jkorn@cmu.edu"><p class="white-text">jkorn@cmu.edu</p></a>
        </div>
        <div class="col s12 m3">
          <a href="https://github.com/vulq"><img src="github-mark.png" style="margin-top:8px;"></a>
          <a href="https://github.com/vulq"><p class="white-text"style="margin-top:21px;">vulq</p></a>
        </div>
        <div class="col s12 m3">
          <a href="https://www.linkedin.com/in/jkorn21"><img src="social22.png" style="margin-top:8px;"></a>
          <a href="https://www.linkedin.com/in/jkorn21"><p class="white-text"style="margin-top:21px;">jkorn21</p></a>
        </div>
      </div>
    </div>
    <div class="container hide-on-med-and-up">
      <div class="row">
        <div class="col s12 m3">
          <a href="tel:973-879-6362"><i class="small mdi-communication-phone white-text"></i></a>
          <a href="tel:973-879-6362"><p class="white-text">(973) 879-6362</p></a>
        </div>
        <div class="col s12 m3">
          <a href="mailto:jkorn@cmu.edu"><i class="small mdi-communication-email white-text"></i></a>
          <a href="mailto:jkorn@cmu.edu"><p class="white-text">jkorn@cmu.edu</p></a>
        </div>
        <div class="col s12 m3">
          <a href="https://github.com/vulq"><img src="github-mark.png" style="margin-top:8px;"></a>
          <a href="https://github.com/vulq"><p class="white-text"style="margin-top:21px;">vulq</p></a>
        </div>
        <div class="col s12 m3">
          <a href="https://www.linkedin.com/in/jkorn21"><img src="social22.png" style="margin-top:8px;"></a>
          <a href="https://www.linkedin.com/in/jkorn21"><p class="white-text"style="margin-top:21px;">jkorn21</p></a>
        </div>
      </div>
    </div>
    <div class="footer-copyright">
      <div class="container">
      © 2017 Joshua Korn
      </div>
    </div>
  </footer>
</html>
